s = "openai"
sorted_s = sorted(s)  # returns a sorted list of characters
sorted_string = ''.join(sorted_s)  # join the list back into a string
print(sorted_string)  # Output: "aeinop"
------------------------------------------------------------------
# To calculate gcd on multiple number
import math
from functools import reduce

# Function to calculate GCD of multiple numbers
def gcd_multiple(numbers):
    return reduce(math.gcd, numbers)

# Example: finding GCD of multiple numbers
numbers = [36, 60, 48]

result = gcd_multiple(numbers)
print(f"GCD of {numbers} is {result}")
-----------------------------------------------------------------
# working with inputs
input:
2
2 3 4
10 1 10

code:

t = int(input())
for test in range(t):
	a = list(map(int, input().split())) # very very important remember this
	for i in range(5):
		a.sort()
		a[0] += 1
	print(a[0]*a[1]*a[2])

2>                             *******************
R = lambda: map(int, input().split())
t, = R()
exec(t * "n, k = R(); *a, = R(); print('YNEOS'[a > sorted(a) and k < 2 :: 2]);")
------------------------------------------------------------------------------------------------------
for query in ("erase", "eraser", "dream", "dreamer"):
    if s.endswith(query):
        s = s[:-len(query)] # if end is negative,then start will start from end
        break
else:         #else block will be executed when break is not executed 
    print('NO')
    exit()
-----------------------------------------------------------------------------------------------------------------------------
import itertools

# Generate all 4-digit permutations using 0 and 2
digits = [0, 2]
permutations = itertools.product(digits, repeat=4)
print(type(permutations[0]))
# Filter and print only 4-digit numbers (ignore those starting with 0)
for perm in permutations:
    if perm[0] != 0:  # Ensure the first digit is not 0
        print(''.join(map(str, perm)))
--------------------------------------------------------------------------------------------------------------------------
#heapq practice in python
import heapq

# 1. heapify: Convert a list into a heap in O(n) time
nums = [25, 9, 5, 19, 13, 3, 7]
heapq.heapify(nums)
print("Heapified list:", nums)  # Output: [3, 9, 5, 19, 13, 25, 7]

# 2. heappush: Insert an element into the heap
heapq.heappush(nums, 2)
print("After heappush(2):", nums)  # Output: [2, 9, 3, 19, 13, 25, 7, 5]

# 3. heappop: Remove and return the smallest element
smallest = heapq.heappop(nums)
print("Smallest element popped:", smallest)  # Output: 2
print("After heappop:", nums)  # Output: [3, 9, 5, 19, 13, 25, 7]

# 4. heappushpop: Push a new item and pop the smallest
pushed_popped = heapq.heappushpop(nums, 6)
print("Pushed and popped:", pushed_popped)  # Output: 3
print("After heappushpop(6):", nums)  # Output: [5, 9, 6, 19, 13, 25, 7]

# 5. heapreplace: Pop the smallest and push a new item
replaced = heapq.heapreplace(nums, 8)
print("Replaced element:", replaced)  # Output: 5
print("After heapreplace(8):", nums)  # Output: [6, 9, 7, 19, 13, 25, 8]

# 6. nlargest: Get the 3 largest elements
largest_three = heapq.nlargest(3, nums)
print("3 largest elements:", largest_three)  # Output: [25, 19, 13]

# 7. nsmallest: Get the 3 smallest elements
smallest_three = heapq.nsmallest(3, nums)
print("3 smallest elements:", smallest_three)  # Output: [6, 7, 8]
------------------------------------------------------------------------------------------------------------------------
import itertools

# 1. count: Infinite iterator starting from a number
counter = itertools.count(start=10, step=2)
print("First 5 elements from count:", [next(counter) for _ in range(5)])  # Output: [10, 12, 14, 16, 18]

# 2. cycle: Infinite iterator cycling through an iterable
cycler = itertools.cycle(['A', 'B', 'C'])
print("First 6 elements from cycle:", [next(cycler) for _ in range(6)])  # Output: ['A', 'B', 'C', 'A', 'B', 'C']

# 3. repeat: Repeats an element infinitely or a specified number of times
repeater = itertools.repeat('X', times=4)
print("Repeat 'X' 4 times:", list(repeater))  # Output: ['X', 'X', 'X', 'X']

# 4. accumulate: Returns accumulated sums (or other binary functions like multiplication)
nums = [1, 2, 3, 4, 5]
acc_sum = itertools.accumulate(nums)
print("Accumulated sum:", list(acc_sum))  # Output: [1, 3, 6, 10, 15]

# 5. chain: Chains multiple iterables together
chained = itertools.chain([1, 2], ['a', 'b'], [True, False])
print("Chained iterables:", list(chained))  # Output: [1, 2, 'a', 'b', True, False]

# 6. combinations: Returns combinations of a specific length from an iterable
comb = itertools.combinations([1, 2, 3], 2)
print("Combinations of 2:", list(comb))  # Output: [(1, 2), (1, 3), (2, 3)]

# 7. permutations: Returns permutations of a specific length from an iterable
perm = itertools.permutations([1, 2, 3], 2)
print("Permutations of 2:", list(perm))  # Output: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

# 8. product: Cartesian product of input iterables
prod = itertools.product([1, 2], ['a', 'b'])
print("Product of [1, 2] and ['a', 'b']:", list(prod))  # Output: [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]

# 9. groupby: Groups elements by a key function
grouped = itertools.groupby('AAAABBBCCDAA')
grouped_result = [(k, list(g)) for k, g in grouped]
print("Grouped elements:", grouped_result)  
# Output: [('A', ['A', 'A', 'A', 'A']), ('B', ['B', 'B', 'B']), ('C', ['C', 'C']), ('D', ['D']), ('A', ['A', 'A'])]

# 10. islice: Slice an iterator
sliced = itertools.islice(range(10), 2, 8, 2)
print("Sliced range(10):", list(sliced))  # Output: [2, 4, 6]
