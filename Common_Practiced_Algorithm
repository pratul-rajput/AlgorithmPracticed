#Binary Search--------------------------------------------------------------------------------------------------------------------
def binary_search(arr, key):
    l, r = 0, len(arr) - 1
    while l<= r:
        mid = l+(r-l) // 2
        if arr[mid] == key:
            return mid
        elif arr[mid] < key:
            l = mid + 1
        else:
            r = mid - 1
    return -1

# Example usage:
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
key = 5
print(binary_search(arr, key))  # Output: 4
-------------------------------------------------------------------------------------------------------------------------------
Most generalised binary search[Modified binary search to solve most binary search problem]
def binary_search(array) -> int:
    def condition(value) -> bool:
        pass

    left, right = min(search_space), max(search_space) # could be [0, n], [1, n] etc. Depends on problem
    while left < right:
        mid = left + (right - left) // 2
        if condition(mid):
            right = mid
        else:
            left = mid + 1
    return left
#bfs----------------------------------------------------------------------------------------------------------------------------
from collections import deque

def bfs(graph, start):
    visited = set()  # Initialize an empty set for visited nodes
    queue = deque([start])  # Initialize the queue with the start node
    visited.add(start)  # Mark the start node as visited
    
    while queue:
        node = queue.popleft()  # Dequeue the next node
        print(node)  # Print the current node
        
        for neighbor in graph[node]:
            if neighbor not in visited:  # Visit unvisited neighbors
                queue.append(neighbor)  # Enqueue the neighbor
                visited.add(neighbor)  # Mark neighbor as visited

# Example usage
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F', 'G'],
    'D': ['B'],
    'E': ['B', 'H'],
    'F': ['C'],
    'G': ['C'],
    'H': ['E']
}

bfs(graph, 'A')

# dfs-----------------------------------------------------------------------------------------------------------------------
def dfs(graph, start):
    visited = set()  # To keep track of visited nodes
    stack = [start]  # Use a list as a stack (LIFO)
    visited.add(start)
    
    while stack:
        node = stack.pop()  # Pop the last node from the stack (LIFO)
        print(node)
        
        # Push all unvisited neighbors to the stack
        for neighbor in graph[node]:
            if neighbor not in visited:
                stack.append(neighbor)
                visited.add(neighbor)
# Example usage
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F', 'G'],
    'D': ['B'],
    'E': ['B', 'H'],
    'F': ['C'],
    'G': ['C'],
    'H': ['E']
}

dfs(graph,'A')
-------------------------------------------------------------------------------------------------------------------------------------------
def dfs_recursive(graph, node, visited=None):
    if visited is None:
        visited = set()
    
    if node not in visited:
        visited.add(node)
        print(node, end=' ')
        for neighbor in graph[node]:
            dfs_recursive(graph, neighbor, visited)

# Example graph represented as an adjacency list
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

print("Recursive DFS:")
dfs_recursive(graph, 'A')
----------------------------------------------------------------------------------------------------------------------------------------------
from collections import deque

def bfs(r, c):
    q = deque()
    visited = set()
    visited.add((r, c))
    q.append((r, c))
    
    while q:
        row, col = q.popleft()
        print(row,col)
        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]
      
        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            if nr in range(rows) and nc in range(cols) and (nr, nc) not in visited:
                q.append((nr, nc))
                visited.add((nr, nc))

# Example usage with your grid
grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
]
rows, cols = len(grid), len(grid[0])

# Example call to bfs function
bfs(0, 0)
-------------------------------------------------------------------------------------------------------------------------------------------------
def dfs(r, c):
    stack = [(r, c)]
    visited = set()
    visited.add((r, c))
    
    while stack:
        row, col = stack.pop()
        print(row,col)
        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]
        
        
        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            if nr in range(rows) and nc in range(cols) and (nr, nc) not in visited:
                stack.append((nr, nc))
                visited.add((nr, nc))

# Example usage with your grid
grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
]
rows, cols = len(grid), len(grid[0])

# Example call to dfs function
dfs(0, 0)
----------------------------------------------------------------------------------------------------------------------------------------------------
def dfs(r, c):
    if (
        r not in range(rows)
        or c not in range(cols)
        or (r, c) in visit
    ):
        return
    
    print(r, c)
    visit.add((r, c))
    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]
    for dr, dc in directions:
        dfs(r + dr, c + dc)

grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
]

visit = set()
rows, cols = len(grid), len(grid[0])

dfs(0, 0)
-------------------------------------------------------------------------------------------------------------------------------------------------------
from collections import deque

# Function to return list containing vertices in Topological order.


def topological_sort(adj, V):
	# Vector to store indegree of each vertex
	indegree = [0] * V
	for i in range(V):
		for vertex in adj[i]:
			indegree[vertex] += 1

	# Queue to store vertices with indegree 0
	q = deque()
	for i in range(V):
		if indegree[i] == 0:
			q.append(i)
	result = []
	while q:
		node = q.popleft()
		result.append(node)
		# Decrease indegree of adjacent vertices as the current node is in topological order
		for adjacent in adj[node]:
			indegree[adjacent] -= 1
			# If indegree becomes 0, push it to the queue
			if indegree[adjacent] == 0:
				q.append(adjacent)

	# Check for cycle
	if len(result) != V:
		print("Graph contains cycle!")
		return []
	return result


if __name__ == "__main__":
	n = 4 # Number of nodes

	# Edges
	edges = [[0, 1], [1, 2], [3, 1], [3, 2]]

	# Graph represented as an adjacency list
	adj = [[] for _ in range(n)]

	# Constructing adjacency list
	for edge in edges:
		adj[edge[0]].append(edge[1])

	# Performing topological sort
	print("Topological sorting of the graph:", end=" ")
	result = topological_sort(adj, n)

	# Displaying result
	for vertex in result:
		print(vertex, end=" ")
--------------------------------------------------------------------------------------------------------------------------------------------------------
# A naive recursive implementation
# of 0-1 Knapsack Problem

def knapSack(W, wt, val, n):

    # Base Case
    if n == 0 or W == 0:
        return 0

    # If weight of the nth item is
    # more than Knapsack of capacity W,
    # then this item cannot be included
    # in the optimal solution
    if (wt[n-1] > W):
        return knapSack(W, wt, val, n-1)

    # return the maximum of two cases:
    # (1) nth item included
    # (2) not included
    else:
        return max(
            val[n-1] + knapSack(
                W-wt[n-1], wt, val, n-1),
            knapSack(W, wt, val, n-1))

# end of function knapSack


# Driver Code
if __name__ == '__main__':
    profit = [60, 100, 120]
    weight = [10, 20, 30]
    W = 50
    n = len(profit)
    print knapSack(W, weight, profit, n)

# This code is contributed by Nikhil Kumar Singh
-------------------------------------------------------------------------------------------------------------------------------------------
# This is the memoization approach of
# 0 / 1 Knapsack in Python in simple
# we can say recursion + memoization = DP
def knapsack(wt, val, W, n):

    # base conditions
    if n == 0 or W == 0:
        return 0
    if t[n][W] != -1:
        return t[n][W]

    # choice diagram code
    if wt[n-1] <= W:
        t[n][W] = max(
            val[n-1] + knapsack(
                wt, val, W-wt[n-1], n-1),
            knapsack(wt, val, W, n-1))
        return t[n][W]
    elif wt[n-1] > W:
        t[n][W] = knapsack(wt, val, W, n-1)
        return t[n][W]

# Driver code
if __name__ == '__main__':
    profit = [60, 100, 120]
    weight = [10, 20, 30]
    W = 50
    n = len(profit)
    
    # We initialize the matrix with -1 at first.
    t = [[-1 for i in range(W + 1)] for j in range(n + 1)]
    print(knapsack(weight, profit, W, n))

# This code is contributed by Prosun Kumar Sarkar
----------------------------------------------------------------------------------------------------------------------------
#Bottom up approach or tabulation for 0/1 knapsack
# A Dynamic Programming based Python
# Program for 0-1 Knapsack problem
# Returns the maximum value that can
# be put in a knapsack of capacity W
def knapSack(W, wt, val, n):
    K = [[0 for x in range(W + 1)] for x in range(n + 1)]

    # Build table K[][] in bottom up manner
    for i in range(n + 1):
        for w in range(W + 1):
            if i == 0 or w == 0:
                K[i][w] = 0
            elif wt[i-1] <= w:
                K[i][w] = max(val[i-1]
                              + K[i-1][w-wt[i-1]],
                              K[i-1][w])
            else:
                K[i][w] = K[i-1][w]

    return K[n][W]


# Driver code
if __name__ == '__main__':
    profit = [60, 100, 120]
    weight = [10, 20, 30]
    W = 50
    n = len(profit)
    print(knapSack(W, weight, profit, n))

# This code is contributed by Bhavya Jain
--------------------------------------------------------------------------------------------------------------------------------
#space optimized Approach for 0/1 KnapSack Problem
#This is the best approach for 0/1 knapSack problem 

def knapSack(W, wt, val, n):
    
    # Making the dp array
    dp = [0 for i in range(W+1)]

    # Taking first i elements
    for i in range(1, n+1):
      
        # Starting from back,
        # so that we also have data of
        # previous computation when taking i-1 items
        for w in range(W, 0, -1):
            if wt[i-1] <= w:
                
                # Finding the maximum value
                dp[w] = max(dp[w], dp[w-wt[i-1]]+val[i-1])
    
    # Returning the maximum value of knapsack
    return dp[W]


# Driver code
if __name__ == '__main__':
    profit = [60, 100, 120]
    weight = [10, 20, 30]
    W = 50
    n = len(profit)
    print(knapSack(W, weight, profit, n))


# This code is contributed by Suyash Saxena
--------------------------------------------------------------------------------------------------------------
def findRedundantConnection(edges):
    par = [i for i in range(len(edges) + 1)]
    rank = [1] * (len(edges) + 1)

    def find(n):
        if par[n] != n:
            par[n] = find(par[n])  # Path compression
        return par[n]

    def union(n1, n2):
        p1, p2 = find(n1), find(n2)

        if p1 == p2:
            return False  # They are already connected (cycle detected)
        
        # Union by rank
        if rank[p1] > rank[p2]:
            par[p2] = p1
            rank[p1] += rank[p2]
        else:
            par[p1] = p2
            rank[p2] += rank[p1]
        return True

    # Iterate through each edge and attempt to union the nodes
    for n1, n2 in edges:
        if not union(n1, n2):  # If union fails, return the redundant edge
            return [n1, n2]

# Example usage
edges = [[1, 2], [2, 3], [3, 4], [1, 4], [1, 5]]
redundant_edge = findRedundantConnection(edges)
print("Redundant edge:", redundant_edge)





def dsu(edges):
    sets=set(u for edge in edges for u in edge)
    n=len(sets)
    par=[i for i in range(n)]
    rank=[1]*(n)
    
    def find(n):
        if par[n]!=n:
            par[n]=find(par[n])
        return par[n]
    def union(n1,n2):
        p1,p2=find(n1),find(n2)
        
        if p1==p2:
            return 0
        if rank[p1]>rank[p2]:
            par[p2]=p1
            rank[p1]+=rank[p2]
        else:
            par[p1]=p2
            rank[p2]+=rank[p1]
        return 1
    for n1,n2 in edges:
        if not union(n1,n2):
            print("False")
            print(n1,n2)
            
        
edges = [
    (0, 1),
    (1, 2),
    (2, 3),
    (3, 4),
    (4, 5),
    (5, 6),
    (6, 7),
    (7, 8),
    (8, 0),  # This creates a large cycle
    (2, 8)   # Additional connection that creates a connection between different components
]

dsu(edges)
--------------------------------------------------------------------------------------------------------------------------------------------------------
#Longest common subsequence[gfg]
def get_lcs_length(S1, S2):
    m = len(S1)
    n = len(S2)

    # Initializing a matrix of size (m+1)*(n+1)
    dp = [[0] * (n + 1) for x in range(m + 1)]

    # Building dp[m+1][n+1] in bottom-up fashion
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if S1[i - 1] == S2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j],
                               dp[i][j - 1])

    # dp[m][n] contains length of LCS for S1[0..m-1]
    # and S2[0..n-1]
    return dp[m][n]


if __name__ == "__main__":
    S1 = "AGGTAB"
    S2 = "GXTXAYB"
    print("Length of LCS is", get_lcs_length(S1, S2))
---------------------------------------------------------------------------------------------------------------------------------------------------------
import heapq

# 1. heapify: Convert a list into a heap in O(n) time
nums = [25, 9, 5, 19, 13, 3, 7]
heapq.heapify(nums)
print("Heapified list:", nums)  # Output: [3, 9, 5, 19, 13, 25, 7]

# 2. heappush: Insert an element into the heap
heapq.heappush(nums, 2)
print("After heappush(2):", nums)  # Output: [2, 9, 3, 19, 13, 25, 7, 5]

# 3. heappop: Remove and return the smallest element
smallest = heapq.heappop(nums)
print("Smallest element popped:", smallest)  # Output: 2
print("After heappop:", nums)  # Output: [3, 9, 5, 19, 13, 25, 7]

# 4. heappushpop: Push a new item and pop the smallest
pushed_popped = heapq.heappushpop(nums, 6)
print("Pushed and popped:", pushed_popped)  # Output: 3
print("After heappushpop(6):", nums)  # Output: [5, 9, 6, 19, 13, 25, 7]

# 5. heapreplace: Pop the smallest and push a new item
replaced = heapq.heapreplace(nums, 8)
print("Replaced element:", replaced)  # Output: 5
print("After heapreplace(8):", nums)  # Output: [6, 9, 7, 19, 13, 25, 8]

# 6. nlargest: Get the 3 largest elements
largest_three = heapq.nlargest(3, nums)
print("3 largest elements:", largest_three)  # Output: [25, 19, 13]

# 7. nsmallest: Get the 3 smallest elements
smallest_three = heapq.nsmallest(3, nums)
print("3 smallest elements:", smallest_three)  # Output: [6, 7, 8]
------------------------------------------------------------------------------------------------------------------------
import itertools

# 1. count: Infinite iterator starting from a number
counter = itertools.count(start=10, step=2)
print("First 5 elements from count:", [next(counter) for _ in range(5)])  # Output: [10, 12, 14, 16, 18]

# 2. cycle: Infinite iterator cycling through an iterable
cycler = itertools.cycle(['A', 'B', 'C'])
print("First 6 elements from cycle:", [next(cycler) for _ in range(6)])  # Output: ['A', 'B', 'C', 'A', 'B', 'C']

# 3. repeat: Repeats an element infinitely or a specified number of times
repeater = itertools.repeat('X', times=4)
print("Repeat 'X' 4 times:", list(repeater))  # Output: ['X', 'X', 'X', 'X']

# 4. accumulate: Returns accumulated sums (or other binary functions like multiplication)
nums = [1, 2, 3, 4, 5]
acc_sum = itertools.accumulate(nums)
print("Accumulated sum:", list(acc_sum))  # Output: [1, 3, 6, 10, 15]

# 5. chain: Chains multiple iterables together
chained = itertools.chain([1, 2], ['a', 'b'], [True, False])
print("Chained iterables:", list(chained))  # Output: [1, 2, 'a', 'b', True, False]

# 6. combinations: Returns combinations of a specific length from an iterable
comb = itertools.combinations([1, 2, 3], 2)
print("Combinations of 2:", list(comb))  # Output: [(1, 2), (1, 3), (2, 3)]

# 7. permutations: Returns permutations of a specific length from an iterable
perm = itertools.permutations([1, 2, 3], 2)
print("Permutations of 2:", list(perm))  # Output: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

# 8. product: Cartesian product of input iterables
prod = itertools.product([1, 2], ['a', 'b'])
print("Product of [1, 2] and ['a', 'b']:", list(prod))  # Output: [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]

# 9. groupby: Groups elements by a key function
grouped = itertools.groupby('AAAABBBCCDAA')
grouped_result = [(k, list(g)) for k, g in grouped]
print("Grouped elements:", grouped_result)  
# Output: [('A', ['A', 'A', 'A', 'A']), ('B', ['B', 'B', 'B']), ('C', ['C', 'C']), ('D', ['D']), ('A', ['A', 'A'])]

# 10. islice: Slice an iterator
sliced = itertools.islice(range(10), 2, 8, 2)
print("Sliced range(10):", list(sliced))  # Output: [2, 4, 6]
----------------------------------------------------------------------------------------------------------------------------------
